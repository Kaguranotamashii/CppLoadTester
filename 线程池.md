下面以抢外卖优惠券为例,详细说明线程池里信号量和互斥锁的作用.

### 场景描述
假设某外卖平台推出一批数量有限的优惠券,用户可以在活动页面点击领取.想象有很多用户(线程)同时尝试抢这些优惠券,平台服务器就像一个线程池,要处理这些并发的抢券请求.

### 没有信号量和互斥锁的问题
- **超发优惠券**:多个用户同时尝试领取优惠券时,可能会出现同时读取到剩余优惠券数量不为 0 的情况,从而都认为自己可以领取,导致优惠券超发.例如,本来只剩下 1 张优惠券,两个用户同时读取到剩余数量为 1,都进行领取操作,结果就会发出 2 张优惠券.
- **数据不一致**:在更新剩余优惠券数量时,如果多个用户同时操作,可能会导致数据更新混乱,无法准确记录剩余优惠券数量.

### 引入互斥锁
互斥锁就像优惠券领取系统的一把锁,同一时间只允许一个用户进行领取操作.

#### 工作流程
1. 当一个用户点击领取优惠券时,系统会先尝试获取这把锁(加锁).
2. 获取到锁后,系统会检查剩余优惠券数量是否足够.如果足够,就进行领取操作,更新剩余优惠券数量;如果不足,就提示用户优惠券已领完.
3. 领取操作完成后,系统会释放这把锁(解锁),让其他用户可以继续尝试领取.

#### 代码对应
在你的线程池代码里,`queueLocker` 就类似这个互斥锁.在处理抢券请求时,要保证同一时间只有一个线程可以修改优惠券数量这个共享资源.比如模拟代码如下:
```cpp
#include <iostream>
#include <pthread.h>

pthread_mutex_t couponLock;
int remainingCoupons = 10;

void* claimCoupon(void* arg) {
    pthread_mutex_lock(&couponLock);  // 加锁
    if (remainingCoupons > 0) {
        remainingCoupons--;
        std::cout << "用户领取优惠券成功,剩余优惠券数量: " << remainingCoupons << std::endl;
    } else {
        std::cout << "优惠券已领完" << std::endl;
    }
    pthread_mutex_unlock(&couponLock);  // 解锁
    return nullptr;
}

```
通过互斥锁,保证了同一时间只有一个线程可以修改优惠券数量,避免了超发和数据不一致的问题.

### 引入信号量
信号量就像优惠券剩余数量的指示器,它能告诉线程是否还有优惠券可以领取.

#### 工作流程
1. 系统初始化时,信号量的值被设置为优惠券的初始数量.
2. 当一个用户点击领取优惠券时,系统会先对信号量执行 `wait` 操作.如果信号量的值大于 0,说明还有优惠券可以领取,信号量的值减 1,用户可以继续进行领取操作;如果信号量的值为 0,说明优惠券已领完,用户无法领取.
3. 当有新的优惠券补充时,系统会对信号量执行 `post` 操作,信号量的值加 1.

#### 代码对应
在你的线程池代码里,`queueEventNum` 就类似这个信号量.在处理抢券请求时,线程可以通过信号量知道是否还有优惠券可以领取.模拟代码如下:
```cpp
#include <iostream>
#include <pthread.h>
#include <semaphore.h>

sem_t couponSemaphore;
int remainingCoupons = 10;

void* claimCoupon(void* arg) {
    if (sem_wait(&couponSemaphore) == 0) {  // 等待信号量
        // 有优惠券可以领取
        remainingCoupons--;
        std::cout << "用户领取优惠券成功,剩余优惠券数量: " << remainingCoupons << std::endl;
    } else {
        std::cout << "优惠券已领完" << std::endl;
    }
    return nullptr;
}

```
通过信号量,线程可以知道是否还有优惠券可以领取,避免了无效的尝试,提高了系统效率.

### 总结
- **互斥锁**:保证了对共享资源(优惠券数量)的互斥访问,防止多个线程同时修改数据导致的超发和数据不一致问题.
- **信号量**:用于线程间的同步,让线程知道是否还有优惠券可以领取,避免了线程的无效尝试,提高了系统的整体性能. 